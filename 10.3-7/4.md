# 개인 공부

## 파이썬

### 딕셔너리
<br>

> * 딕셔너리는 가변형데이터 형식이고, 영어 사전이나 국어 사전을 생각하면 된다. 딕셔너리는 쌍 2개가 하나로 묶인 자료구조이며 `apple:사과` 이렇게 의미 있는 두 값을 연결하여 구성한다.
> * 딕셔너리는 중괄호 {}로 묶어 구성하며 키(Key)와 값(Value)의 쌍으로 구성되어 있다.

`딕셔너리변수 = {키1:값1, 키2:값2, 키3:값3, ...}`

<br>

- 딕셔너리 생성
```python
dic1 = {1 : 'a', 2 : 'b', 3 : 'c'}
dic1
```

<br>

반대로 생성 가능
```python
dic1 = {'a' : 1, 'b' : 2, 'c' : 3}
dic1
```


> * 키와 값은 사용자가 지정하는 것으므로 어떤 값을 반드시 사용해야한다는 규정은 없다. 주의할 점은 딕셔너리에는 순서가 없어 생성한 순서대로 딕셔너리가 구성되어 있다는 보장을 할 수 없다.

<br>

- 딕셔너리 생성
```python
stu1 = {'학번' : 1000, '이름' : '홍길동' , '학과':'컴퓨터학과'}
print(stu1)
#{'학번': 1000, '이름': '홍길동', '학과': '컴퓨터학과'}
```
<br>

- 딕셔너리 추가
```python
stu1['연락처'] = '010-0000-1111'
print(stu1)
#{'학번': 1000, '이름': '홍길동', '학과': '컴퓨터학과', '연락처': '010-0000-1111'}
```

<br>

- 중복 키 값 입력 시 새로운 쌍이 추가되는 것이 아닌 기존의 값이 변경된다. 딕셔너리 특성상 키는 유일해야하기 때문이다.

<br>

- 딕셔너리 삭제
```python
del(stu1['학과'])
print(stu1)
#{'학번': 1000, '이름': '홍길동', '연락처': '010-0000-1111'}  
```

- 딕셔너리 중복 키 처리(마지막에 있는 키가 적용)
```python
stu1 = {'학번' : 1000, '이름' : '홍길동' , '학과':'컴퓨터학과', '학번' : 2000}
print(stu1)
#{'학번': 2000, '이름': '홍길동', '학과': '컴퓨터학과'}
```

<br>

- 딕셔너리 사용
```python
#키로 값에 접근하는 코드
print(stu1['학번'])
print(stu1['이름'])
print(stu1['학과'])
```
<br>

- 딕셔너리 제공 함수(딕셔너리.get(키))
```python
stu1.get('이름')
```
- 딕셔너리이름[키]는 없는 키를 호출하면 오류 발생
- 딕셔너리.get(키)는 없는 키 호출 시 아무것도 반환하지 않는다.

<br>

- 딕셔너리 모든 키 반환
```python
print(stu1.keys())
#dict_keys(['학번', '이름', '학과'])

#dict_keys가 보기 싫으면
list(stu1.keys())
```

<br>

- 딕셔너리이름.values()함수는 딕셔너리의 모든 값을 리스트로 만들어 반환
```python
#딕셔너리 모든 값 반환
stu1.values()
print(list(stu1.values()))
```

- 딕셔너리 안에 해당 키 유무 확인
(in)
```python
'이름' in stu1
'주소' in stu1
#True
#False
```
<br>

### 세트
<br>

> * 세트는 키만 모아 놓은 딕셔너리의 특수한 형태
> * 딕셔너리의 키는 중복되면 안되므로 세트에 들어 있는 값은 항상 유일
> * 세트 생성하는 방법은 딕셔너리처럼 중괄호({}) 사용하지만 : 없이 값을 입력한다
> * 가변형 데이터 형식
<br>

```python
mySet1 = {1,2,3,3,3,4}
mySet1
#{1,2,3,4}
```
<br>

- 결과를 보면 중복된 키는 자동으로 하나만 남는다. 세트의 이런 특성을 잘 활용하면 기능을 편리하게 작성할 수 있다. 예를 들어 편의점에 판매되는 물품 목록을 리스트에 순차적으로 저장한다고 할 때 결산할 판매된 물품의 전체 수량이 아닌 종류만 파악하고 싶다면 다음과 같이 리스트를 세트로 변경한다.

```python
saleList = ['삼각김밥', '바나나', '도시락', '삼각김밥', '삼각김밥', '도시락', '삼각김밥']
print(saleList)
#{'삼각김밥', '바나나', '도시락'}
```

<br>

- set 함수는 리스트, 튜플, 딕셔너리 등을 세트로 변경시켜는 역할을 한다. 세트는 딕셔너리와 같이 별도의 순서로 저장되지 않는다.

<br>

```python
mySet1 = {1,2,3,4,5}
mySet2 = {4,5,6,7}
mySet1 & mySet2 #교집합 {4, 5}
mySet1 | mySet2 #합집합 {1,2,3,4,5,6,7}
mySet1 - mySet2 #차집합 {1, 2, 3}
mySet1 ^ mySet2 #대칭 차집합 {1, 2, 3, 6, 7}
```
- 이렇게도 표현
```python
mySet1.intersection(mySet2) #교집합
mySet1.union(mySet2) #합집합
mySet1.difference(mySet2) #차집합
mySet1.symmetric_difference(mySet2) #대칭 차집합
```

### 문자열
<br>

> * 문자열은 문자를 연속해서 저장해 놓은 데이터 형식으로, 파이썬에서는 문자열을 큰따옴표(" ")나 작은따옴표(' ')로 묶어서 표현한다. 문자열은 한번 데이터를 저장해 놓으면 변경할 수 없는 불변형 데이터 형식이다.
<br>

- 문자열 기본
    - 리스트는 [ ]로 묶고, 문자열은 따옴표로 묶는다.
    ```python
    ss = "자료구조 & 알고리즘"
    ss[0]
    ss[1:4]
    ss[4:]
    #'자'
    #'료구조'
    #&알고리즘

    #뛰어쓰기도 문자열의 하나로 봄
    ```

    <br>

    - 더하기(+), 곱하기(*) 기호를 사용하여 문자열 반복 가능
    ```python
    ss = '파이썬' + '최고'
    ss
    ss = '파이썬' * 3
    ss
    #파이썬최고
    #파이썬파이썬파이썬
    ```
    <br>

    - 문자열 길이 파악
    ```python
    ss = '파이썬abcd'
    print(len(ss))
    #7
    ```
    <br>

- 문자열 검색
    - count(), find(), rfind(), index(), rindex() 함수를 사용하면 문자열을 찾을 수 있다.
    ```python
    ss = '파이썬 공부는 즐겁습니다. 물론 모든 공부가 다 재미있지는 않죠. ^^'
    ss.count('공부')
    print(ss.find('공부'), ss.rfind('공부'), ss.find('공부', 5), ss.find('없다'))
    print(ss.index('공부'), ss.rindex('공부'), ss.index('공부', 5))
    print(ss.startswith('파이썬'), ss.startswith('파이썬', 10), ss.endswith('^^'))

    #출력
    #2
    #4 21 21 -1
    #4 21 21
    #True False True
    ```
    <br>

    > * `count('찾을문자열')` 함수는 `찾을 문자열`이 몇 개 들어 있는지 세어주는 함수이다.
    > * `find('찾을문자열')` 함수는 `찾을문자열`이 왼쪽 끝(0번 위치)부터 시작해서 몇 번째에 위치하는지 찾는다.
    > * `rfind('찾을문자열')` 함수는 find()와 반대로 `찾을문자열`을 오른쪽부터 찾는다.
    순서 번호는 왼쪽에서 출발한 번호
    > * `find('공부', 5)`는 왼쪽에서 5번째 글자(`부`) 부터 시작
    > * 찾을라는 문자열이 없으면 -1 반환
    > * `index()`함수도 find()와 동일하지만 없는 문자열을 찾으면 오류가 발생